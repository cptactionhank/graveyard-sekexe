#!/usr/bin/env bash

### Configuration
#####################################################################

# Environment variables and their defaults
LOG_LEVEL="${LOG_LEVEL:-7}" # 7 = debug -> 0 = emergency


### Functions
#####################################################################

function _fmt ()      {
	local color="\033[0m"
	local color_reset="\033[0m"
	case "${1}" in
		emergency) 	color="\033[1;31m";;
		alert) 			color="\033[0;31m";;
		critical) 	color="\033[0;31m";;
		error) 			color="\033[0;31m";;
		warning) 		color="\033[1;33m";;
		notice) 		color="\033[0;32m";;
		info) 			color="\033[0;34m";;
		debug) 			color="\033[1;30m";;
		*) 					color="\033[0;30m";;
	esac
	lvl=$(echo "${1:0:5}" | tr "[:lower:]" "[:upper:]")
	# remove color formatting if colors are not supported
	if [ "0$(tput colors 2> /dev/null)" -lt 8 ]; then
		# Don't use colors on pipes or non-recognized terminals
		color=""; color_reset=""
	fi
	echo -e "$(date +"%Y-%m-%d %H:%M:%S") ${color}$(printf "[%5s]" "${lvl}")${color_reset}";
}
emergency() {                              echo "$(_fmt emergency) ${*}" 1>&2 || true; }
alert()     { ([ "${LOG_LEVEL}" -ge 1 ] && echo "$(_fmt alert) ${*}" 1>&2) 		|| true; }
critical()  { ([ "${LOG_LEVEL}" -ge 2 ] && echo "$(_fmt critical) ${*}" 1>&2) || true; }
error()     { ([ "${LOG_LEVEL}" -ge 3 ] && echo "$(_fmt error) ${*}" 1>&2) 		|| true; }
warning()   { ([ "${LOG_LEVEL}" -ge 4 ] && echo "$(_fmt warning) ${*}" 1>&2) 	|| true; }
notice()    { ([ "${LOG_LEVEL}" -ge 5 ] && echo "$(_fmt notice) ${*}" 1>&2) 	|| true; }
info()      { ([ "${LOG_LEVEL}" -ge 6 ] && echo "$(_fmt info) ${*}" 1>&2) 		|| true; }
debug()     { ([ "${LOG_LEVEL}" -ge 7 ] && echo "$(_fmt debug) ${*}" 1>&2) 		|| true; }


### Runtime
#####################################################################

# go back to where we were invoked
cd "$WORKDIR"

save_and_shutdown() {
  # force clean shutdown
  halt -f
}

# make sure we shut down cleanly
trap save_and_shutdown EXIT INT TERM

# configure path to include /usr/local
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# can't do much without proc!
mount -t proc none "/proc"

# pseudo-terminal devices
mkdir -p "/dev/pts"
mount -t devpts none "/dev/pts"

# shared memory a good idea
mkdir -p "/dev/shm"
mount -t tmpfs none "/dev/shm"

# sysfs a good idea
mount -t sysfs none "/sys"

# pidfiles and such like
mkdir -p "/var/run"
mount -t tmpfs none "/var/run"

# takes the pain out of cgroups
cgroups-mount

# some storage for docker
mkdir -p "/var/lib/docker"
# mount none "/var/lib/docker" -t hostfs -o "/var/lib/docker"
mount -t tmpfs -o size=8g tmpfs "/var/lib/docker"

mkdir -p "/etc/docker"
# mount none "/etc/docker" -t hostfs -o "/etc/docker"
mount -t tmpfs -o size=10m tmpfs "/etc/docker"

export DOCKER_CERT_PATH=/var/lib/docker

# mkdir -p "/etc/docker"
# mount none "/etc/docker" -t hostfs -o "/etc/docker" \
# 	|| mount -t tmpfs -o size=8g tmpfs "/etc/docker"

mount -t hostfs -o "$LOGDIR" none "/var/log"

# configure networking
ip addr add 127.0.0.1 dev lo
ip link set lo up
ip addr add 10.1.1.1/24 dev eth0
ip link set eth0 up
ip route add default via 10.1.1.254
echo "1" > "/proc/sys/net/ipv4/ip_forward"

# This is to handle when /etc/resolv.conf -> /run/resolvconf/resolv.conf
if [ -L "/etc/resolv.conf" ]; then
	mkdir -p "$(dirname "$(readlink --canonicalize-missing "/etc/resolv.conf")")"
	if [ ! -f "/etc/resolv.conf" ]; then
		cat "/var/log/resolv.conf" > "/etc/resolv.conf"
	fi
fi
[ -f "/var/log/stdout" ] && exec >> "/var/log/stdout"
[ -f "/var/log/stderr" ] && exec 2>> "/var/log/stderr"

# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# bits of this were adapted from lxc-checkconfig
# see also https://github.com/lxc/lxc/blob/lxc-1.0.2/src/lxc/lxc-checkconfig.in

possibleConfigs=(
	'/proc/config.gz'
	"/boot/config-$(uname -r)"
	"/usr/src/linux-$(uname -r)/.config"
	'/usr/src/linux/.config'
)

if [ $# -gt 0 ]; then
	CONFIG="$1"
else
	: ${CONFIG:="${possibleConfigs[0]}"}
fi

if ! command -v zgrep &> /dev/null; then
	zgrep() {
		zcat "$2" | grep "$1"
	}
fi

is_set() {
	zgrep "CONFIG_$1=[y|m]" "$CONFIG" > /dev/null
}

# see http://en.wikipedia.org/wiki/ANSI_escape_code#Colors
declare -A colors=(
	[black]=30
	[red]=31
	[green]=32
	[yellow]=33
	[blue]=34
	[magenta]=35
	[cyan]=36
	[white]=37
)
color() {
	color=()
	if [ "$1" = 'bold' ]; then
		color+=( '1' )
		shift
	fi
	if [ $# -gt 0 ] && [ "${colors[$1]}" ]; then
		color+=( "${colors[$1]}" )
	fi
	local IFS=';'
	echo -en '\033['"${color[*]}"m
}
wrap_color() {
	text="$1"
	shift
	color "$@"
	echo -n "$text"
	color reset
	echo
}

wrap_good() {
	echo "$(wrap_color "$1" white): $(wrap_color "$2" green)"
}
wrap_bad() {
	echo "$(wrap_color "$1" bold): $(wrap_color "$2" bold red)"
}
wrap_warning() {
	wrap_color >&2 "$*" red
}

check_flag() {
	if is_set "$1"; then
		wrap_good "CONFIG_$1" 'enabled'
	else
		wrap_bad "CONFIG_$1" 'missing'
	fi
}

check_flags() {
	for flag in "$@"; do
		echo "- $(check_flag "$flag")"
	done
}

if [ ! -e "$CONFIG" ]; then
	wrap_warning "warning: $CONFIG does not exist, searching other paths for kernel config..."
	for tryConfig in "${possibleConfigs[@]}"; do
		if [ -e "$tryConfig" ]; then
			CONFIG="$tryConfig"
			break
		fi
	done
	if [ ! -e "$CONFIG" ]; then
		wrap_warning "error: cannot find kernel config"
		wrap_warning "  try running this script again, specifying the kernel config:"
		wrap_warning "    CONFIG=/path/to/kernel/.config $0 or $0 /path/to/kernel/.config"
		exit 1
	fi
fi

wrap_color "info: reading kernel config from $CONFIG ..." white
echo

echo 'Generally Necessary:'

echo -n '- '
cgroupSubsystemDir="$(awk '/[, ](cpu|cpuacct|cpuset|devices|freezer|memory)[, ]/ && $3 == "cgroup" { print $2 }' /proc/mounts | head -n1)"
cgroupDir="$(dirname "$cgroupSubsystemDir")"
if [ -d "$cgroupDir/cpu" -o -d "$cgroupDir/cpuacct" -o -d "$cgroupDir/cpuset" -o -d "$cgroupDir/devices" -o -d "$cgroupDir/freezer" -o -d "$cgroupDir/memory" ]; then
	echo "$(wrap_good 'cgroup hierarchy' 'properly mounted') [$cgroupDir]"
else
	if [ "$cgroupSubsystemDir" ]; then
		echo "$(wrap_bad 'cgroup hierarchy' 'single mountpoint!') [$cgroupSubsystemDir]"
	else
		echo "$(wrap_bad 'cgroup hierarchy' 'nonexistent??')"
	fi
	echo "    $(wrap_color '(see https://github.com/tianon/cgroupfs-mount)' yellow)"
fi

if [ "$(cat /sys/module/apparmor/parameters/enabled 2>/dev/null)" = 'Y' ]; then
	echo -n '- '
	if command -v apparmor_parser &> /dev/null; then
		echo "$(wrap_good 'apparmor' 'enabled and tools installed')"
	else
		echo "$(wrap_bad 'apparmor' 'enabled, but apparmor_parser missing')"
		echo -n '    '
		if command -v apt-get &> /dev/null; then
			echo "$(wrap_color '(use "apt-get install apparmor" to fix this)')"
		elif command -v yum &> /dev/null; then
			echo "$(wrap_color '(your best bet is "yum install apparmor-parser")')"
		else
			echo "$(wrap_color '(look for an "apparmor" package for your distribution)')"
		fi
	fi
fi

flags=(
	NAMESPACES {NET,PID,IPC,UTS}_NS
	DEVPTS_MULTIPLE_INSTANCES
	CGROUPS CGROUP_CPUACCT CGROUP_DEVICE CGROUP_FREEZER CGROUP_SCHED CPUSETS
	MACVLAN VETH BRIDGE
	NF_NAT_IPV4 IP_NF_FILTER IP_NF_TARGET_MASQUERADE
	NETFILTER_XT_MATCH_{ADDRTYPE,CONNTRACK}
	NF_NAT NF_NAT_NEEDED

	# required for bind-mounting /dev/mqueue into containers
	POSIX_MQUEUE
)
check_flags "${flags[@]}"
echo

echo 'Optional Features:'
{
	check_flags MEMCG_SWAP 
	check_flags MEMCG_SWAP_ENABLED
	if  is_set MEMCG_SWAP && ! is_set MEMCG_SWAP_ENABLED; then
		echo "    $(wrap_color '(note that cgroup swap accounting is not enabled in your kernel config, you can enable it by setting boot option "swapaccount=1")' bold black)"
	fi
}
flags=(
	RESOURCE_COUNTERS
	CGROUP_PERF
)
check_flags "${flags[@]}"

echo '- Storage Drivers:'
{
	echo '- "'$(wrap_color 'aufs' blue)'":'
	check_flags AUFS_FS | sed 's/^/  /'
	if ! is_set AUFS_FS && grep -q aufs /proc/filesystems; then
		echo "    $(wrap_color '(note that some kernels include AUFS patches but not the AUFS_FS flag)' bold black)"
	fi
	check_flags EXT4_FS_POSIX_ACL EXT4_FS_SECURITY | sed 's/^/  /'

	echo '- "'$(wrap_color 'btrfs' blue)'":'
	check_flags BTRFS_FS | sed 's/^/  /'

	echo '- "'$(wrap_color 'devicemapper' blue)'":'
	check_flags BLK_DEV_DM DM_THIN_PROVISIONING EXT4_FS EXT4_FS_POSIX_ACL EXT4_FS_SECURITY | sed 's/^/  /'

	echo '- "'$(wrap_color 'overlay' blue)'":'
	check_flags OVERLAY_FS EXT4_FS_SECURITY EXT4_FS_POSIX_ACL | sed 's/^/  /'
} | sed 's/^/  /'
echo
# halt -f
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------



# execute the command
debug "going to run command $*"
info "Number of loop devices: $(find /dev/loop* | wc -l)"
/usr/bin/env sh -c "${CMD}"
# preserve commands exit code
echo $? >/var/log/status
