#!/usr/bin/env bash

### Configuration
#####################################################################

# Environment variables and their defaults
LOG_LEVEL="${LOG_LEVEL:-7}" # 7 = debug -> 0 = emergency


### Functions
#####################################################################

function _fmt ()      {
	local color="\033[0m"
	local color_reset="\033[0m"
	case "${1}" in
		emergency) 	color="\033[1;31m";;
		alert) 			color="\033[0;31m";;
		critical) 	color="\033[0;31m";;
		error) 			color="\033[0;31m";;
		warning) 		color="\033[1;33m";;
		notice) 		color="\033[0;32m";;
		info) 			color="\033[0;34m";;
		debug) 			color="\033[1;30m";;
		*) 					color="\033[0;30m";;
	esac
	lvl=$(echo "${1:0:5}" | tr "[:lower:]" "[:upper:]")
	# remove color formatting if colors are not supported
	if [ "0$(tput colors 2> /dev/null)" -lt 8 ]; then
		# Don't use colors on pipes or non-recognized terminals
		color=""; color_reset=""
	fi
	echo -e "$(date +"%Y-%m-%d %H:%M:%S") ${color}$(printf "[%5s]" "${lvl}")${color_reset}";
}
emergency() {                              echo "$(_fmt emergency) ${*}" 1>&2 || true; }
alert()     { ([ "${LOG_LEVEL}" -ge 1 ] && echo "$(_fmt alert) ${*}" 1>&2) 		|| true; }
critical()  { ([ "${LOG_LEVEL}" -ge 2 ] && echo "$(_fmt critical) ${*}" 1>&2) || true; }
error()     { ([ "${LOG_LEVEL}" -ge 3 ] && echo "$(_fmt error) ${*}" 1>&2) 		|| true; }
warning()   { ([ "${LOG_LEVEL}" -ge 4 ] && echo "$(_fmt warning) ${*}" 1>&2) 	|| true; }
notice()    { ([ "${LOG_LEVEL}" -ge 5 ] && echo "$(_fmt notice) ${*}" 1>&2) 	|| true; }
info()      { ([ "${LOG_LEVEL}" -ge 6 ] && echo "$(_fmt info) ${*}" 1>&2) 		|| true; }
debug()     { ([ "${LOG_LEVEL}" -ge 7 ] && echo "$(_fmt debug) ${*}" 1>&2) 		|| true; }


### Runtime
#####################################################################

# go back to where we were invoked
cd "$WORKDIR"

save_and_shutdown() {
	local exit_code="$?"
	debug "User-Mode Linux, exit status: $exit_code"
	# Capture and save the commands exit code and save it in the $LOGDIR
	echo "$exit_code" > "$LOGDIR/status"
  # force clean shutdown
  halt -f
}

# make sure we shut down cleanly
trap save_and_shutdown EXIT INT TERM

export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
mount -t tmpfs none /tmp
mount -t tmpfs none /var/run
mount -t hostfs -o $LOGDIR none /var/log
mount -t tmpfs none /var/lib/docker
mount -t proc none /proc
mkdir /dev/pts
mount -t devpts none /dev/pts
mkdir /dev/shm
mknod -m 444 /dev/urandom c 1 9
mount -t tmpfs none /dev/shm
mount -t sysfs none /sys
mount -t tmpfs none /sys/fs/cgroup
for SUBSYS in memory devices cpuset cpu
do
mkdir /sys/fs/cgroup/$SUBSYS
mount -t cgroup -o $SUBSYS none /sys/fs/cgroup/$SUBSYS
done
echo 1 > /proc/sys/net/ipv4/ip_forward
echo 0 > /proc/sys/kernel/printk
ip addr add 127.0.0.1 dev lo
ip link set lo up
ip addr add 10.1.1.1/24 dev eth0
ip link set eth0 up
ip route add default via 10.1.1.254
# This is to handle when /etc/resolv.conf -> /run/resolvconf/resolv.conf
[ -L /etc/resolv.conf ] && {
	mkdir -p "$(dirname "$(readlink --canonicalize-missing "/etc/resolv.conf")")"
	[ -f /etc/resolv.conf ] || {
		cat /var/log/resolv.conf > /etc/resolv.conf
	}
}
[ -f /var/log/output ] && {
	exec >>/var/log/output
	exec 2>>/var/log/output
}

/usr/bin/env sh -c "$*"
# echo $? >/var/log/status
